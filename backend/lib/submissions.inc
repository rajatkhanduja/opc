<?
include_once  (dirname(__FILE__) . "/../config.inc" );
require_once  "lib/db.inc" ;
require_once "lib/user.inc" ;

/**
 * Abstraction of a submission.
 */

class Submission { 
  /**
   * The submission id.
   */
  public $id ; 

  /**
   * The user/team who owns this submission.
   */
  public $user; 

  /**
   * The user/team who owns the submission. Should always be same as
   * $user. 
   * @deprecated Use $user instead.
   */
  public $team ; 

  /**
   * The problem id this submission was submitted against.
   */
  public $problemid; 
  
  /**
   * The programming language of this submission. 
   */
  public $lang ; 
  
  /**
   * The state of this submission. 
   * This records the state of the submission when the submission was queried.
   */
  public $state; 

  /**
   * The set score of the submission.
   */
  public $score; 

  /**
   * The time at which the submission was made. This is PHP time, and not 
   * necessarily a human readable time. However its best to assume that it
   * can be anything.
   * @warning Changes to this variable will not be recorded when using
   * commitChanges()
   */
  public $time ;

  /**
   * The path to the result file.
   * @deprecated This is now redundant since the pathtoresult can be computed
   * from the id of the code. @see getPathToResult() 
   */
  public $pathtoresult ; 

  /**
   * A boolean value indicating whether this submission is counted toward the
   * the ranklist (whatever that may be) in the frontend. Typically can be
   * used to invalidate a users submission, without affecting his score or
   * submission counters.
   */
  public $notcounted ; 

  /**
   * A md5sum hash of the code. Note that this is allowed to be empty, it may
   * be used if the frontend wants to prevent multiple submissions to the
   * same problem.
   */
  public $hash ;

  /**
   * The owner (contest/realm) of the submission 
   */
  public $owner; 

  /**
   * Accessor functions
   */

  public function getId() { 
  	return $this->id; 
  }

  public function getUser() { 
	return $this->user; 
  }

  public function getProblemId() { 
	return $this->problemid; 
  }

  public function getPathToCode() { 
	if (!empty($this->pathtocode ) ) 
	  return config::getFilename($this->pathtocode) ; 
	return config::getFilename("data/uploads/{$this->user}.{$this->problemid}.{$this->id}") ;
  }

  public function getLang() { 
	return $this->lang ; 
  }

  public function getScore() { 
	return $this->score; 
  }

  public function getTime() { 
	return $this->time; 
  }

  public function getPathToResult() { 
	return config::getFilename("data/results/{$this->id}.xml") ;
  }

  public function getIsCounted() { 
	return !empty($this->notcounted); 
  }

  public function getHash() { 
	return $this->hash ; 
  }
  public function getOwner() { 
	return $this->owner ;
  }
  public function getXmlFile() { 
	return config::getFilename("data/uploads/{$this->id}.xml") ;
  }
  /**
   * construct this object from another object which looks like the database
   * contents
   * @param object, which is return value from pg_get_obj or suitable database
   * query.
   */
  function __construct($obj) { 
	$this->id = $obj->id; 
	$this->team = $this->user = $obj->team ;
	$this->problemid = $obj->problemid ; 
	$this->lang = $obj->lang ; 
	$this->state = $obj->state; 
	$this->score = $obj->score ;
	$this->pathtoresult = $this->getPathToResult() ; 
	$this->pathtocode = $this->getPathToCode() ;
	$this->notcounted = $obj->notcounted; 
	$this->hash = $obj->hash ; 
  }

  function commitChanges() { 
	  $db = contestDB::get_zend_db(); 
	  $data = array(
		  "team" => $this->getUser() ,
		  "problemid" => $this->getProblemId() ,
		  "lang" => $this->getLang(), 
		  "state" => $this->state,
		  "score" => $this->score, 
		  "hash" => "{$this->hash}" ) ;
	  if ( $this->notcounted ) 
		  $data["notcounted"] = true ;

	  if ( $this->getOwner() ) 
		$data['owner'] = $this->getOwner(); 

	  $where = array("id = {$this->id}"  );
	  
	  $db->update(SubmissionTable::tablename, $data, $where) ;
  }
  
}
/**
 * Every submission is known by a submission ID 
 * 
 * Submission ID is assumed to be auto generated by the database
 * see docs/db for details.
 */

class SubmissionTable {

  /**
   * The tablename used for all submission accesses.
   */
  const tablename='submissionqueue' ;

  /**
   * This is the id of the postgresql serial that allows us to keep track
   * of the current submission id. 
   * @see add_to_queue() 
   */
  const serial   ='submissionqueue_id' ; 

  /**
   * Add a submission to queue
   *
   * @param $user (string) Team/User name
   * @param $problemid (string) problem ID
   * @param $lang (string) language
   *
   * @return (class Submission) A submission class.
   */
  public static function add_to_queue ( $user,
					$problemid,
					$lang) {

	  $db = contestDB::get_zend_db() ; 
	  
	  $isadm = User::factory($user)->isAdmin();

	  $data = array() ;
	  if ( $user ) $data['team'] = $user; 
	  if ( $problemid) $data['problemid'] = $problemid; 
	  if ( $lang) $data['lang'] = $lang; 
	  $data['state'] = 'processing' ; 
	  $data['score'] = 0 ;

	  $res = $db->insert(SubmissionTable::tablename, $data) ;

	  /*
	   * TODO: the following line is Postgres dependent.
	   */
	  return self::get_submission(
		  $db->lastSequenceId(SubmissionTable::serial ));

  }

  /**
   * Get submissions from the queue
   * 
   * @param $id The numeric submission ID
   * @return  Returns and object with the data
   */
  public static function get_submission( $id) {
	  $id = (int) $id ; 
	  $db = contestDB::get_zend_db() ;
	  $res = $db->select()->from(SubmissionTable::tablename)
		  ->where('id = ?', $id)->query() ;

	  return new Submission($res->fetch())  ;
  }

  public static function get_submission_xml_file($id) { 
	return realpath(get_file_name("data/uploads/$id.xml") );
  }
  /**
   * Get a list of waiting submissions, in a way decided ``nice''
   * for the queue-manager
   *
   * @param $limit (integer) number of elements to get
   */

  public static function get_waiting_queue($limit) {
	contestDB::connect() ;
	
	$res = contestDB::query("select * from " . 
							SubmissionTable::tablename . 
							" where state='waiting' order by id asc" .  
							( $limit != 0 ? " limit $limit " : "" )
							);

	if ( ! $res  )
	  throw new Exception("Unable to get waiting queue" ) ;
	
	$ret = array() ;
	
	$count = pg_num_rows ( $res ) ;

	while ( $count -- ) 
	  array_push ( $ret, pg_fetch_object($res)->id ) ;
	
	return $ret ; 
  }
  
  /**
   * Set a parameter (or database field value) for a submission.
   * 
   * @param $id The submission id
   * @param $field (string) The parameter (field) to change.
   * @param $value The value to change to. Currently only string is
   *                supported.
   * @return Non-zero value on success.
   * @see get_field_value 
   */
  public static function set_field_value ( $id, $field, $value) {
	contestDB::connect();
	$res = contestDB::query("update " 
							. SubmissionTable::tablename 
							. " set $field='" . $value 
							. "' where id=$id"  ) ;
	return (pg_affected_rows($res) > 0 ) ;
  }

  /**
   * Get a parameter (or database field value) for a submission. 
   * 
   * @param $id The submission id
   * @param $field The parameter ($field) whose value is being queried.
   * @return The current value of the parameter.
   */
  public static function get_field_value( $id, $field) {
	contestDB::connect() ;
	if ( !is_int($id) )
	  throw new Exception("Not an integer");
	$res = contestDB::query(" select $field from " 
							.SubmissionTable::tablename 
							. " where id=$id " );
	if (pg_num_rows($res) == 0 ) return NULL ;
	$ar =  pg_fetch_row($res)  ;
	return $ar [0] ;
  }

  /**
   * Set the submission state. A submission state is typical of the form
   * "Waiting", "Queued", "Accepted", "Wrong Answer" etc., however you are 
   * allowed to set any string. 
   * @param $id The numeric submission id.
   * @param $state the new state of the submission.
   * @param $oldstate The oldstate of the submission. If $oldstate is not NULL
   *        then the the state of the submission will be changed only if the
   *        the state was $oldstate previously.
   * @return TRUE if the state was changed. FALSE on error and/or the previous
   *        state was not $oldstate.
   */
  public static function set_state( $id, $state, $oldstate = NULL) {
	contestDB::connect() ;
	$state = pg_escape_string($state);
	$res = contestDB::query("update " 
							. SubmissionTable::tablename 
							. " set state='$state' where id=$id " 
							. ( empty($oldstate)? "" : 
								" and state='$oldstate' " ) );
	return (pg_affected_rows($res) > 0 ) ;
  }

  /**
   * Get the state of the submission.
   * @param $id the id
   * @return the state
   */
   public static function get_state($id) { 
          return SubmissionTable::get_field_value($id, "state") ;
   }  
  /**
   * Only sets the score in the queue database.
   * Does NOT update the score in the caches/team results
   * or for that matter any other database.
   *
   * @param $id integer the submission id
   * @param $score integer the new score
   */
  public static function set_score ($id, $score) {
	contestDB::connect() ;
	$res = contestDB::query("update " 
							. SubmissionTable::tablename
							. " set score=" .  $score
							. " where id=$id " );

	return ($res);
  }

  /**
   * Attempts to find duplicate submissions. Seaches earlier submissions
   * "hash" field to see if there exists a submission with the given $hash.
   * @param $team Restrict the search to submissions by this team.
   * @param $probid Restrict the search to submissions to this problem.
   * @param $hash The hash of the file to search for.
   * @return TRUE if and only if the hash was found.
   */
  public static function exists_submission_by_hash($team,$probid,$hash) {
	contestDB::connect() ;
	$team = pg_escape_string($team);
	$sql = "select * from " . SubmissionTable::tablename . 
	  " where hash='$hash' " ;
	if ( !empty($team) ) $sql .= " and team='$team' and problemid='$probid' " ;
	$res = contestDB::query($sql) ;
	return (pg_num_rows ($res) != 0) ;
  }

  /**
   * Gets a list of elements in the queue. Note that this doesn't restrict
   * the elements to "Waiting" or "Queue"d elements.
   * @param $offset (Integer) the starting point to get the queue from. 
   *        Note that this need not always be the Submission id.
   * @param $limit (integer) the number of elements to fetch. 
   * @param $user (string) limit the searches to a particular user
   *        if !empty($user). Default value is "".
   * @return list of submission objects.
   */
  public static function get_queue ($offset, $limit, $user='', $owner=NULL) {
	$db = contestDB::get_zend_db() ;
	
	$query = $db->select() -> from(self::tablename) 
	  ->limit($limit, $offset) ; 

	if ( !empty($user) ) $query = $query->where('team = ?', $user) ;
	if ( !empty($owner)) $query = $query->where('owner = ?', $owner);

	$res = $query->order("id DESC")->query() ;

	if ( empty($res) )
	  throw new Exception("Unable to get queue" ) ;
	
	return $res->fetchAll() ;
  }

  /**
   * Get a count of number of objects that matches the given criteria.
   * @param $team team to match.
   * @param $problemid problemid to match.
   * @param $counted if $counted is true, then only problems that have
   *        "noncounted" field to true are matched.
   * @return integer signifying the number of elements.
   */
  public static function get_count($team=NULL,$problemid=NULL,$counted=NULL) { 

	$db = contestDB::get_zend_db() ; 
	$query = $db->select()->from(self::tablename, array("res" => "COUNT(*)"));
 
	if ( !empty($team) ) $query = $query->where('team = ?', $team) ;
	if ( !empty($problemid) ) $query = $query->where('problemid = ?', 
													 $problemid);
	if ( !empty($counted) ) $query = $query->where('notcounted = ?',
												   $counted) ;
	
								 
	$ret = $query -> query() ; 
	$res = $ret->fetch(); 
	return $res->res ; 
  }
}

?>
